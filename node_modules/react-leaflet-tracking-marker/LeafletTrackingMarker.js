"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.LeafletTrackingMarker = void 0;

var _core = require("@react-leaflet/core");

var _BaseMarker = require("./BaseMarker");

var _excluded = ["position", "previousPosition", "rotationAngle"];

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var defaultPosition = [0, 0];

var computeBearing = function computeBearing() {
  var previousPosition = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : defaultPosition;
  var nexPosition = arguments.length > 1 ? arguments[1] : undefined;
  var bearing = Math.atan2(nexPosition[0] - previousPosition[0], nexPosition[1] - previousPosition[1]);
  bearing = bearing * (180 / Math.PI);
  bearing = (bearing + 360) % 360;
  bearing = 360 - bearing;
  return bearing;
};

var createMarker = function createMarker(_ref, ctx) {
  var position = _ref.position,
      previousPosition = _ref.previousPosition,
      rotationAngle = _ref.rotationAngle,
      options = _objectWithoutProperties(_ref, _excluded);

  var bearingAngle = rotationAngle !== null && rotationAngle !== void 0 ? rotationAngle : computeBearing(previousPosition, position);
  var instance = new _BaseMarker.BaseMarker(position, _objectSpread(_objectSpread({}, options), {}, {
    bearingAngle: bearingAngle
  }));
  return {
    instance: instance,
    context: _objectSpread(_objectSpread({}, ctx), {}, {
      overlayContainer: instance
    })
  };
};

var updateMarker = function updateMarker(marker, props, prevProps) {
  var position = props.position,
      previousPosition = props.previousPosition,
      duration = props.duration,
      keepAtCenter = props.keepAtCenter,
      icon = props.icon,
      zIndexOffset = props.zIndexOffset,
      opacity = props.opacity,
      draggable = props.draggable,
      rotationOrigin = props.rotationOrigin,
      rotationAngle = props.rotationAngle;

  if (prevProps.position !== position && typeof duration == 'number') {
    marker.slideTo(position, {
      duration: duration,
      keepAtCenter: keepAtCenter
    });
  }

  if (icon && icon !== prevProps.icon) {
    marker.setIcon(icon);
  }

  if (zIndexOffset && zIndexOffset !== prevProps.zIndexOffset) {
    marker.setZIndexOffset(zIndexOffset);
  }

  if (opacity && opacity !== prevProps.opacity) {
    marker.setOpacity(opacity);
  }

  if (marker.dragging && draggable !== prevProps.draggable) {
    if (draggable === true) {
      marker.dragging.enable();
    } else {
      marker.dragging.disable();
    }
  }

  if (rotationAngle !== null && rotationAngle !== void 0) {
    marker.setRotationAngle(rotationAngle);
  } else if ((previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition[0]) !== position[0] && (previousPosition === null || previousPosition === void 0 ? void 0 : previousPosition[1]) !== position[1]) {
    var bearingAngle = computeBearing(previousPosition, position);
    marker.setRotationAngle(bearingAngle);
  }

  if (rotationOrigin !== prevProps.rotationOrigin) {
    marker.setRotationOrigin(rotationOrigin);
  }
};

var LeafletTrackingMarker = (0, _core.createLayerComponent)(createMarker, updateMarker);
exports.LeafletTrackingMarker = LeafletTrackingMarker;